Instructions, as of 6/10/2024

=============================================================================================================================
HOW TO USE THIS PROGRAM:
=============================================================================================================================

First, make sure you are using a Raspberry Pi 5. While this will (sort of) work on a Pi 4,
performance is much worse.

Hopefully you are working on a machine where someone has already installed all the
files and libraries you need. If not, skip to the bottom "installing on a new machine",
then come back here when you are done.

Locate the directory where the program resides. Most likely, it is in:
/home/user/Documents/github/Pi5WebcamRecorder

Now launch the program. There are three ways to do this:

    Method 1: For beginners. From command line, cd to the program directory, then type:
    python -m WEBCAM_RECORD.py

    Method 2: For intermediate users. Open Thonny (the Pi's built-in Python IDE). Open
    WEBCAM_RECORD.py, then run it with the triangle "play" button. Thonny also has a debugger
    which is helpful when coding new features or fixing bugs.

    Method 3: For advanced users. Install PyCharm CE by first installing Pi-Apps, and using
    Pi-Apps to install PyCharm CE. This gives you a much more powerful debugger, albeit with
    a much steeper learning curve.

Upon launch, it will scan the system for up to 4 connected USB cameras, then display them
in a 2x2 grid. The position in the grid matches the position of the physical USB port.
For example, any camera plugged into the top-left USB port will show up in the top left of
the 2x2 grid. The cameras are numbered 0-3, in the following order:

  -------------
  |  0  |  1  |
  -------------
  |  2  |  3  |
  -------------

Once running, it will respond to the following keyboard keys:

    "Q":            Typing this stops any ongoing recordings, and quits the program
    Left cursor:    Cycles through cameras in descending order
    Right cursor:   Cycles through cameras in ascending order
    0-3:            Typing a camera number will manually start/stop recording of that camera. A red dot appears in the corner to indicate ongoing recording.

This program also monitors GPIO pins 4-7. A low-to-high transition (i.e. from 0V to 3.3V)
on the following pins has the following effects:

    GPIO4:          Starts recording camera 0
    GPIO5:          Starts recording camera 1
    GPIO6:          Starts recording camera 2
    GPIO7:          Starts recording camera 3

If you are wondering why I avoided GPIO pins 0-3, it is because they are used for I2C communications.

Starting a recording generates 3 files: one stores video, a second stores timestamps of
individual frames, and a third stores timestamps of low-to-high GPIO transitions, which
indicate start times for individual behavior trials.

Each camera has completely separate files, and there is no data mixing between cameras/files.
Each filename begins with the date in YYYY-MM-DD_HHMM format, followed by the camera number.
For example, camera 0, recorded on June 9, 2024 at 5:38pm, generates these 3 files:

    2024-06-09_1738_Cam0_Video.avi              # Video file in H264 format
    2024-06-09_1738_Cam0_Timestamp.txt          # Text file with timestamps of each video frame
    2024-06-09_1738_Cam0_Timestamp_TTL.txt      # Text file with timestamps of low-to-high TTL transitions, representing trial cue onsets

Note the two separate text files, one for video frame timestamps and one for GPIO/TTL timestamps.

The H264 format achieves remarkably high compression ratios, with files typically <2MB per minute.
Typical storage requirements are as follows:

    1 GB:     About 8 hours (or more) of continuous recording.
    1 TB:     About 1 year of continuous 24/7 recording.
    1 TB:     About 3 years if recording two 1-hour sessions per day from 4 animals (i.e. 8 total hours/day)

Basic video parameters are as follows:

    Frames per second: 10                # Set on line 19 of CamObj.py file
    Codec: h264                          # Set on line 21 of CamObj.py
    Pixel resolution: 640x480            # Set on lines 34-35 of CamObj.py file

Max resolution and frame rate are limited by the CPU's ability to compress to h264 format. If you need
more resolution or higher frame rate, you can switch from h264 to mp4v format (MPEG-4) which is faster, but
has poorer compression ratio and requires ~5x more disk space.

This program is intended to run on a Raspberry Pi 5. It will (sort of) run on a Pi 4, but performance is frustratingly
poor if you have more than 1 camera. This program also runs (sort of) under Windows, but it lacks the ability to
distinguish which USB port is which, meaning camera position will be somewhat random. Strangely, the Windows H264 encoder
(from Cisco systems, v1.8) also achieves much worse compression ratios than the Raspberry Pi version.


=============================================================================================================================
KNOWN SHORTCOMINGS:
=============================================================================================================================

1. Currently, GPIO pins can remotely start a recording, but they cannot stop a recording. There is a way to do it,
which I plan to test later this week. But for now, you have to manually stop the recording by typing the camera number.

2. Stopping a recording causes the system to spend ~200ms closing files and flushing data. During this 200ms, you
may get about 2 dropped frames from any other cameras that are recording. There is a way around this, which I will
likely implement later this week. For now, one workaround is to keep all recordings going until all sessions are done.

3. The video frame timestamp is when the frame was READ by the Python code, but the actual pixel data was likely
CAPTURED from the camera sensor up to 70ms earlier. It is then stored in an internal buffer until the Pi reads
it. For more accurate timestamps, I need to explicitly measure the delay from capture to read (e.g. by blinking a
LED from a TTL signal that is also fed into the GPIO pin) and then subtract it from the recorded timestamp.
Again, will implement this later in the week.


=============================================================================================================================
  INSTALLING ON A NEW MACHINE:
=============================================================================================================================

Hopefully you are using a machine where someone has already installed everything for you. If not, please
follow these three annoying steps:

STEP 1: Clone the github repository. There are two ways to do this:

  Method 1: Easy, but you won't be able to make changes to the Github repository. Open a command prompt, then type:
  git clone https://github.com/JhouLab/Pi5WebcamRecorder

  Now go to STEP 2.

  Method 2: Harder, but gives you to ability to make changes to the Github repository. This is essential if
  you need to fix bugs or add features. First download Github Desktop for Raspberry Pi from these instructions:
  https://pi-apps.io/install-app/install-github-desktop-on-raspberry-pi/

  In a nutshell, you first need to install Pi-Apps using this command:
  wget -qO- https://raw.githubusercontent.com/Botspot/pi-apps/master/install | bash

  Then launch Pi-Apps, select "Programming", then "Github Desktop", which is the purple cat icon, and
  then click the button to install Github Desktop. Now launch it from the main Raspberry Pi menu, under
  "Accessories", then log into the lab github account with jhoulab1@gmail.com as username and standard password.

  Now, clone the repository Pi5WebcamRecorder

STEP 2:
  Install OpenCV. Instructions for installing it on a Pi5 are here:
  https://qengineering.eu/install%20opencv%20on%20raspberry%20pi%205.html

  (I happened to use method #2 in the link above, but the others will likely work also)

STEP 3:
  Annoyingly, the Pi5 uses different GPIO hardware than the Pi4, which is not compatible with the
  default GPIO library RPi.GPIO. There are several workarounds, but the simplest is to uninstall the
  standard library and install python3-rpi-lpgio, a drop-in replacement. This is done by typing
  the following two lines into a command prompt:

  sudo apt remove  python3-rpi.gpio
  sudo apt install python3-rpi-lgpio


After that, everything should run. If so, CONGRATULATIONS. If not, please email tjhou@som.umaryland.edu for help.
